/*
Export API

Export OpenAPI definitions

API version: 20.0.0
Contact: apiteam@pleo.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package export

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"reflect"
	"strings"
)

// ExportAPIV1ApiService ExportAPIV1Api service
type ExportAPIV1ApiService service

type ApiCreateExportJobEventV1Request struct {
	ctx                  context.Context
	ApiService           *ExportAPIV1ApiService
	createExportJobEvent *CreateExportJobEvent
}

func (r ApiCreateExportJobEventV1Request) CreateExportJobEvent(createExportJobEvent CreateExportJobEvent) ApiCreateExportJobEventV1Request {
	r.createExportJobEvent = &createExportJobEvent
	return r
}

func (r ApiCreateExportJobEventV1Request) Execute() (*http.Response, error) {
	return r.ApiService.CreateExportJobEventV1Execute(r)
}

/*
CreateExportJobEventV1 Create an Export Job Event

	           The Export Job Events are used to move the Export Job through the export lifecycle,
	           updating the status and results of the export.
	           This endpoint is used to update the status and failure reasons (if failed) of an export job,
	           i.e. start a job, mark a job as failed, complete a job, cancel a job, etc.

	           Events:

	           - started: Used to start processing an export job. This allows the integration
	                   service to start processing the export job items.
	           - failed: Use this to mark a job as failed when an irrecoverable error happens,
	                   and this could be while processing the export job items.
	           - completed: Used to indicate that all the export job items have been successfully processed.
	           - completed_with_errors: Used when all the export job items have been processed, but some of then failed.
	           - canceled: Used to indicate if the integration service is unable, for any reason,
	                   to continue processing the export job.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateExportJobEventV1Request
*/
func (a *ExportAPIV1ApiService) CreateExportJobEventV1(ctx context.Context) ApiCreateExportJobEventV1Request {
	return ApiCreateExportJobEventV1Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *ExportAPIV1ApiService) CreateExportJobEventV1Execute(r ApiCreateExportJobEventV1Request) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExportAPIV1ApiService.CreateExportJobEventV1")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/export-job-events"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createExportJobEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateExportJobV1Request struct {
	ctx             context.Context
	ApiService      *ExportAPIV1ApiService
	createExportJob *CreateExportJob
}

func (r ApiCreateExportJobV1Request) CreateExportJob(createExportJob CreateExportJob) ApiCreateExportJobV1Request {
	r.createExportJob = &createExportJob
	return r
}

func (r ApiCreateExportJobV1Request) Execute() (*DataResponseExportJob, *http.Response, error) {
	return r.ApiService.CreateExportJobV1Execute(r)
}

/*
CreateExportJobV1 Create a new export job

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateExportJobV1Request
*/
func (a *ExportAPIV1ApiService) CreateExportJobV1(ctx context.Context) ApiCreateExportJobV1Request {
	return ApiCreateExportJobV1Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DataResponseExportJob
func (a *ExportAPIV1ApiService) CreateExportJobV1Execute(r ApiCreateExportJobV1Request) (*DataResponseExportJob, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DataResponseExportJob
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExportAPIV1ApiService.CreateExportJobV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/export-jobs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createExportJob
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v DataResponseExportJob
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExportJobByIdV1Request struct {
	ctx        context.Context
	ApiService *ExportAPIV1ApiService
	jobId      string
}

func (r ApiGetExportJobByIdV1Request) Execute() (*DataResponseExportJob, *http.Response, error) {
	return r.ApiService.GetExportJobByIdV1Execute(r)
}

/*
GetExportJobByIdV1 Get an Export Job

Retrieve an export job for a given export job ID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param jobId
	@return ApiGetExportJobByIdV1Request
*/
func (a *ExportAPIV1ApiService) GetExportJobByIdV1(ctx context.Context, jobId string) ApiGetExportJobByIdV1Request {
	return ApiGetExportJobByIdV1Request{
		ApiService: a,
		ctx:        ctx,
		jobId:      jobId,
	}
}

// Execute executes the request
//
//	@return DataResponseExportJob
func (a *ExportAPIV1ApiService) GetExportJobByIdV1Execute(r ApiGetExportJobByIdV1Request) (*DataResponseExportJob, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DataResponseExportJob
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExportAPIV1ApiService.GetExportJobByIdV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/export-jobs/{jobId}"
	localVarPath = strings.Replace(localVarPath, "{"+"jobId"+"}", url.PathEscape(parameterToString(r.jobId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v DataResponseExportJob
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExportJobItemsV1Request struct {
	ctx          context.Context
	ApiService   *ExportAPIV1ApiService
	jobId        string
	status       *string
	before       *string
	after        *string
	offset       *int64
	limit        *int32
	sortingKeys  *[]string
	sortingOrder *[]PageOrder
}

// Filter by the export job item status
func (r ApiGetExportJobItemsV1Request) Status(status string) ApiGetExportJobItemsV1Request {
	r.status = &status
	return r
}

// Lower bound of the page of data to return (cannot be used together with [after] or [offset])
func (r ApiGetExportJobItemsV1Request) Before(before string) ApiGetExportJobItemsV1Request {
	r.before = &before
	return r
}

// Upper bound of the page of data to return (cannot be used together with [before] or [offset])
func (r ApiGetExportJobItemsV1Request) After(after string) ApiGetExportJobItemsV1Request {
	r.after = &after
	return r
}

// Offset of the page of data to return (cannot be used together with [before] or [after])
func (r ApiGetExportJobItemsV1Request) Offset(offset int64) ApiGetExportJobItemsV1Request {
	r.offset = &offset
	return r
}

// The maximum amount of items to return
func (r ApiGetExportJobItemsV1Request) Limit(limit int32) ApiGetExportJobItemsV1Request {
	r.limit = &limit
	return r
}

// The keys to sort the results by
func (r ApiGetExportJobItemsV1Request) SortingKeys(sortingKeys []string) ApiGetExportJobItemsV1Request {
	r.sortingKeys = &sortingKeys
	return r
}

// The order to sort the results by. Must be the same length as [sortingKeys]; one order per key
func (r ApiGetExportJobItemsV1Request) SortingOrder(sortingOrder []PageOrder) ApiGetExportJobItemsV1Request {
	r.sortingOrder = &sortingOrder
	return r
}

func (r ApiGetExportJobItemsV1Request) Execute() (*CursorPaginatedResponseExportJobItem, *http.Response, error) {
	return r.ApiService.GetExportJobItemsV1Execute(r)
}

/*
GetExportJobItemsV1 Get Export Job Items

Fetch a list of export job items

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param jobId
	@return ApiGetExportJobItemsV1Request
*/
func (a *ExportAPIV1ApiService) GetExportJobItemsV1(ctx context.Context, jobId string) ApiGetExportJobItemsV1Request {
	return ApiGetExportJobItemsV1Request{
		ApiService: a,
		ctx:        ctx,
		jobId:      jobId,
	}
}

// Execute executes the request
//
//	@return CursorPaginatedResponseExportJobItem
func (a *ExportAPIV1ApiService) GetExportJobItemsV1Execute(r ApiGetExportJobItemsV1Request) (*CursorPaginatedResponseExportJobItem, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CursorPaginatedResponseExportJobItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExportAPIV1ApiService.GetExportJobItemsV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/export-jobs/{jobId}/items"
	localVarPath = strings.Replace(localVarPath, "{"+"jobId"+"}", url.PathEscape(parameterToString(r.jobId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.before != nil {
		localVarQueryParams.Add("before", parameterToString(*r.before, ""))
	}
	if r.after != nil {
		localVarQueryParams.Add("after", parameterToString(*r.after, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.sortingKeys != nil {
		t := *r.sortingKeys
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("sorting_keys", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("sorting_keys", parameterToString(t, "multi"))
		}
	}
	if r.sortingOrder != nil {
		t := *r.sortingOrder
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("sorting_order", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("sorting_order", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v CursorPaginatedResponseExportJobItem
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExportJobsListV1Request struct {
	ctx          context.Context
	ApiService   *ExportAPIV1ApiService
	companyId    *string
	status       *string
	before       *string
	after        *string
	offset       *int64
	limit        *int32
	sortingKeys  *[]string
	sortingOrder *[]PageOrder
}

// Fetch a list of jobs for a given company
func (r ApiGetExportJobsListV1Request) CompanyId(companyId string) ApiGetExportJobsListV1Request {
	r.companyId = &companyId
	return r
}

// Fetch a list of jobs for a specific status
func (r ApiGetExportJobsListV1Request) Status(status string) ApiGetExportJobsListV1Request {
	r.status = &status
	return r
}

// Lower bound of the page of data to return (cannot be used together with [after] or [offset])
func (r ApiGetExportJobsListV1Request) Before(before string) ApiGetExportJobsListV1Request {
	r.before = &before
	return r
}

// Upper bound of the page of data to return (cannot be used together with [before] or [offset])
func (r ApiGetExportJobsListV1Request) After(after string) ApiGetExportJobsListV1Request {
	r.after = &after
	return r
}

// Offset of the page of data to return (cannot be used together with [before] or [after])
func (r ApiGetExportJobsListV1Request) Offset(offset int64) ApiGetExportJobsListV1Request {
	r.offset = &offset
	return r
}

// The maximum amount of items to return
func (r ApiGetExportJobsListV1Request) Limit(limit int32) ApiGetExportJobsListV1Request {
	r.limit = &limit
	return r
}

// The keys to sort the results by
func (r ApiGetExportJobsListV1Request) SortingKeys(sortingKeys []string) ApiGetExportJobsListV1Request {
	r.sortingKeys = &sortingKeys
	return r
}

// The order to sort the results by. Must be the same length as [sortingKeys]; one order per key
func (r ApiGetExportJobsListV1Request) SortingOrder(sortingOrder []PageOrder) ApiGetExportJobsListV1Request {
	r.sortingOrder = &sortingOrder
	return r
}

func (r ApiGetExportJobsListV1Request) Execute() (*CursorPaginatedResponseExportJob, *http.Response, error) {
	return r.ApiService.GetExportJobsListV1Execute(r)
}

/*
GetExportJobsListV1 Get a list of Export Jobs

Fetch a list of export jobs

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetExportJobsListV1Request
*/
func (a *ExportAPIV1ApiService) GetExportJobsListV1(ctx context.Context) ApiGetExportJobsListV1Request {
	return ApiGetExportJobsListV1Request{
		ApiService: a,
		ctx:        ctx,
		companyId:  a.client.cfg.CompanyID,
	}
}

// Execute executes the request
//
//	@return CursorPaginatedResponseExportJob
func (a *ExportAPIV1ApiService) GetExportJobsListV1Execute(r ApiGetExportJobsListV1Request) (*CursorPaginatedResponseExportJob, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CursorPaginatedResponseExportJob
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExportAPIV1ApiService.GetExportJobsListV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/export-jobs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.companyId != nil {
		localVarQueryParams.Add("company_id", parameterToString(*r.companyId, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.before != nil {
		localVarQueryParams.Add("before", parameterToString(*r.before, ""))
	}
	if r.after != nil {
		localVarQueryParams.Add("after", parameterToString(*r.after, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.sortingKeys != nil {
		t := *r.sortingKeys
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("sorting_keys", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("sorting_keys", parameterToString(t, "multi"))
		}
	}
	if r.sortingOrder != nil {
		t := *r.sortingOrder
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("sorting_order", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("sorting_order", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v CursorPaginatedResponseExportJob
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateExportJobItemsV1Request struct {
	ctx                 context.Context
	ApiService          *ExportAPIV1ApiService
	jobId               string
	updateExportJobItem *[]UpdateExportJobItem
}

func (r ApiUpdateExportJobItemsV1Request) UpdateExportJobItem(updateExportJobItem []UpdateExportJobItem) ApiUpdateExportJobItemsV1Request {
	r.updateExportJobItem = &updateExportJobItem
	return r
}

func (r ApiUpdateExportJobItemsV1Request) Execute() (*ExportJobItemUpdate, *http.Response, error) {
	return r.ApiService.UpdateExportJobItemsV1Execute(r)
}

/*
UpdateExportJobItemsV1 Update Export Job Items

Update the status and other attributes of the export job items in batches of 100. This API only supports updating up to 100 items.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param jobId
	@return ApiUpdateExportJobItemsV1Request
*/
func (a *ExportAPIV1ApiService) UpdateExportJobItemsV1(ctx context.Context, jobId string) ApiUpdateExportJobItemsV1Request {
	return ApiUpdateExportJobItemsV1Request{
		ApiService: a,
		ctx:        ctx,
		jobId:      jobId,
	}
}

// Execute executes the request
//
//	@return ExportJobItemUpdate
func (a *ExportAPIV1ApiService) UpdateExportJobItemsV1Execute(r ApiUpdateExportJobItemsV1Request) (*ExportJobItemUpdate, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ExportJobItemUpdate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExportAPIV1ApiService.UpdateExportJobItemsV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/export-jobs/{jobId}/items"
	localVarPath = strings.Replace(localVarPath, "{"+"jobId"+"}", url.PathEscape(parameterToString(r.jobId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateExportJobItem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v ExportJobItemUpdate
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
