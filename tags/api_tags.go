/*
Tags API

Tags OpenAPI definitions

API version: 31.38.0
Contact: team-expense-core@pleo.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package tags

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"reflect"
	"strings"
)

// TagsApiService TagsApi service
type TagsApiService service

type ApiCreateDimensionValueRequest struct {
	ctx                          context.Context
	ApiService                   *TagsApiService
	tagId                        string
	dimensionId                  string
	tagDimensionValueCreateModel *TagDimensionValueCreateModel
}

func (r ApiCreateDimensionValueRequest) TagDimensionValueCreateModel(tagDimensionValueCreateModel TagDimensionValueCreateModel) ApiCreateDimensionValueRequest {
	r.tagDimensionValueCreateModel = &tagDimensionValueCreateModel
	return r
}

func (r ApiCreateDimensionValueRequest) Execute() (*DataResponseTagDimensionValueModel, *http.Response, error) {
	return r.ApiService.CreateDimensionValueExecute(r)
}

/*
CreateDimensionValue Creates a dimension value

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tagId
	@param dimensionId
	@return ApiCreateDimensionValueRequest
*/
func (a *TagsApiService) CreateDimensionValue(ctx context.Context, tagId string, dimensionId string) ApiCreateDimensionValueRequest {
	return ApiCreateDimensionValueRequest{
		ApiService:  a,
		ctx:         ctx,
		tagId:       tagId,
		dimensionId: dimensionId,
	}
}

// Execute executes the request
//
//	@return DataResponseTagDimensionValueModel
func (a *TagsApiService) CreateDimensionValueExecute(r ApiCreateDimensionValueRequest) (*DataResponseTagDimensionValueModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DataResponseTagDimensionValueModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagsApiService.CreateDimensionValue")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v0/tags/{tagId}/dimensions/{dimensionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"tagId"+"}", url.PathEscape(parameterToString(r.tagId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"dimensionId"+"}", url.PathEscape(parameterToString(r.dimensionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tagDimensionValueCreateModel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v DataResponseTagDimensionValueModel
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateTagRequest struct {
	ctx            context.Context
	ApiService     *TagsApiService
	groupId        string
	tagCreateModel *TagCreateModel
}

func (r ApiCreateTagRequest) TagCreateModel(tagCreateModel TagCreateModel) ApiCreateTagRequest {
	r.tagCreateModel = &tagCreateModel
	return r
}

func (r ApiCreateTagRequest) Execute() (*DataResponseTagModel, *http.Response, error) {
	return r.ApiService.CreateTagExecute(r)
}

/*
CreateTag Creates a new tag sub-resource under the given tag group

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupId
	@return ApiCreateTagRequest
*/
func (a *TagsApiService) CreateTag(ctx context.Context, groupId string) ApiCreateTagRequest {
	return ApiCreateTagRequest{
		ApiService: a,
		ctx:        ctx,
		groupId:    groupId,
	}
}

// Execute executes the request
//
//	@return DataResponseTagModel
func (a *TagsApiService) CreateTagExecute(r ApiCreateTagRequest) (*DataResponseTagModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DataResponseTagModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagsApiService.CreateTag")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v0/tag-groups/{groupId}/tags"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tagCreateModel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v DataResponseTagModel
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteDimensionValueRequest struct {
	ctx         context.Context
	ApiService  *TagsApiService
	tagId       string
	dimensionId string
}

func (r ApiDeleteDimensionValueRequest) Execute() (*DataResponseTagDimensionValueModel, *http.Response, error) {
	return r.ApiService.DeleteDimensionValueExecute(r)
}

/*
DeleteDimensionValue Deletes a dimension value

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tagId
	@param dimensionId
	@return ApiDeleteDimensionValueRequest
*/
func (a *TagsApiService) DeleteDimensionValue(ctx context.Context, tagId string, dimensionId string) ApiDeleteDimensionValueRequest {
	return ApiDeleteDimensionValueRequest{
		ApiService:  a,
		ctx:         ctx,
		tagId:       tagId,
		dimensionId: dimensionId,
	}
}

// Execute executes the request
//
//	@return DataResponseTagDimensionValueModel
func (a *TagsApiService) DeleteDimensionValueExecute(r ApiDeleteDimensionValueRequest) (*DataResponseTagDimensionValueModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DataResponseTagDimensionValueModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagsApiService.DeleteDimensionValue")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v0/tags/{tagId}/dimensions/{dimensionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"tagId"+"}", url.PathEscape(parameterToString(r.tagId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"dimensionId"+"}", url.PathEscape(parameterToString(r.dimensionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v DataResponseTagDimensionValueModel
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteTagRequest struct {
	ctx        context.Context
	ApiService *TagsApiService
	tagId      string
}

func (r ApiDeleteTagRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteTagExecute(r)
}

/*
DeleteTag Deletes tag by id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tagId
	@return ApiDeleteTagRequest
*/
func (a *TagsApiService) DeleteTag(ctx context.Context, tagId string) ApiDeleteTagRequest {
	return ApiDeleteTagRequest{
		ApiService: a,
		ctx:        ctx,
		tagId:      tagId,
	}
}

// Execute executes the request
func (a *TagsApiService) DeleteTagExecute(r ApiDeleteTagRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagsApiService.DeleteTag")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v0/tags/{tagId}"
	localVarPath = strings.Replace(localVarPath, "{"+"tagId"+"}", url.PathEscape(parameterToString(r.tagId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetDimensionValueRequest struct {
	ctx         context.Context
	ApiService  *TagsApiService
	tagId       string
	dimensionId string
}

func (r ApiGetDimensionValueRequest) Execute() (*DataResponseTagDimensionValueModel, *http.Response, error) {
	return r.ApiService.GetDimensionValueExecute(r)
}

/*
GetDimensionValue Gets a dimension value

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tagId
	@param dimensionId
	@return ApiGetDimensionValueRequest
*/
func (a *TagsApiService) GetDimensionValue(ctx context.Context, tagId string, dimensionId string) ApiGetDimensionValueRequest {
	return ApiGetDimensionValueRequest{
		ApiService:  a,
		ctx:         ctx,
		tagId:       tagId,
		dimensionId: dimensionId,
	}
}

// Execute executes the request
//
//	@return DataResponseTagDimensionValueModel
func (a *TagsApiService) GetDimensionValueExecute(r ApiGetDimensionValueRequest) (*DataResponseTagDimensionValueModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DataResponseTagDimensionValueModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagsApiService.GetDimensionValue")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v0/tags/{tagId}/dimensions/{dimensionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"tagId"+"}", url.PathEscape(parameterToString(r.tagId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"dimensionId"+"}", url.PathEscape(parameterToString(r.dimensionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v DataResponseTagDimensionValueModel
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTagRequest struct {
	ctx        context.Context
	ApiService *TagsApiService
	tagId      string
}

func (r ApiGetTagRequest) Execute() (*DataResponseTagModel, *http.Response, error) {
	return r.ApiService.GetTagExecute(r)
}

/*
GetTag Returns tag by id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tagId
	@return ApiGetTagRequest
*/
func (a *TagsApiService) GetTag(ctx context.Context, tagId string) ApiGetTagRequest {
	return ApiGetTagRequest{
		ApiService: a,
		ctx:        ctx,
		tagId:      tagId,
	}
}

// Execute executes the request
//
//	@return DataResponseTagModel
func (a *TagsApiService) GetTagExecute(r ApiGetTagRequest) (*DataResponseTagModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DataResponseTagModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagsApiService.GetTag")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v0/tags/{tagId}"
	localVarPath = strings.Replace(localVarPath, "{"+"tagId"+"}", url.PathEscape(parameterToString(r.tagId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v DataResponseTagModel
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTagDimensionValuesRequest struct {
	ctx        context.Context
	ApiService *TagsApiService
	tagId      string
}

func (r ApiGetTagDimensionValuesRequest) Execute() (*DataResponseListTagDimensionValueModel, *http.Response, error) {
	return r.ApiService.GetTagDimensionValuesExecute(r)
}

/*
GetTagDimensionValues Fetches dimension values

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tagId
	@return ApiGetTagDimensionValuesRequest
*/
func (a *TagsApiService) GetTagDimensionValues(ctx context.Context, tagId string) ApiGetTagDimensionValuesRequest {
	return ApiGetTagDimensionValuesRequest{
		ApiService: a,
		ctx:        ctx,
		tagId:      tagId,
	}
}

// Execute executes the request
//
//	@return DataResponseListTagDimensionValueModel
func (a *TagsApiService) GetTagDimensionValuesExecute(r ApiGetTagDimensionValuesRequest) (*DataResponseListTagDimensionValueModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DataResponseListTagDimensionValueModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagsApiService.GetTagDimensionValues")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v0/tags/{tagId}/dimensions"
	localVarPath = strings.Replace(localVarPath, "{"+"tagId"+"}", url.PathEscape(parameterToString(r.tagId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v DataResponseListTagDimensionValueModel
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTagsRequest struct {
	ctx             context.Context
	ApiService      *TagsApiService
	groupId         string
	before          *string
	after           *string
	offset          *int64
	limit           *int32
	sortingKeys     *[]string
	sortingOrder    *[]PageOrder
	includeArchived *bool
}

// Lower bound of the page of data to return (cannot be used together with [after] or [offset])
func (r ApiGetTagsRequest) Before(before string) ApiGetTagsRequest {
	r.before = &before
	return r
}

// Upper bound of the page of data to return (cannot be used together with [before] or [offset])
func (r ApiGetTagsRequest) After(after string) ApiGetTagsRequest {
	r.after = &after
	return r
}

// Offset of the page of data to return (cannot be used together with [before] or [after])
func (r ApiGetTagsRequest) Offset(offset int64) ApiGetTagsRequest {
	r.offset = &offset
	return r
}

// The maximum amount of items to return
func (r ApiGetTagsRequest) Limit(limit int32) ApiGetTagsRequest {
	r.limit = &limit
	return r
}

// The keys to sort the results by
func (r ApiGetTagsRequest) SortingKeys(sortingKeys []string) ApiGetTagsRequest {
	r.sortingKeys = &sortingKeys
	return r
}

// The order to sort the results by. Must be the same length as [sortingKeys]; one order per key
func (r ApiGetTagsRequest) SortingOrder(sortingOrder []PageOrder) ApiGetTagsRequest {
	r.sortingOrder = &sortingOrder
	return r
}

func (r ApiGetTagsRequest) IncludeArchived(includeArchived bool) ApiGetTagsRequest {
	r.includeArchived = &includeArchived
	return r
}

func (r ApiGetTagsRequest) Execute() (*CursorPaginatedResponseTagModel, *http.Response, error) {
	return r.ApiService.GetTagsExecute(r)
}

/*
GetTags Returns tags for given tag group

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupId
	@return ApiGetTagsRequest
*/
func (a *TagsApiService) GetTags(ctx context.Context, groupId string) ApiGetTagsRequest {
	return ApiGetTagsRequest{
		ApiService: a,
		ctx:        ctx,
		groupId:    groupId,
	}
}

// Execute executes the request
//
//	@return CursorPaginatedResponseTagModel
func (a *TagsApiService) GetTagsExecute(r ApiGetTagsRequest) (*CursorPaginatedResponseTagModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CursorPaginatedResponseTagModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagsApiService.GetTags")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v0/tag-groups/{groupId}/tags"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.before != nil {
		localVarQueryParams.Add("before", parameterToString(*r.before, ""))
	}
	if r.after != nil {
		localVarQueryParams.Add("after", parameterToString(*r.after, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.sortingKeys != nil {
		t := *r.sortingKeys
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("sorting_keys", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("sorting_keys", parameterToString(t, "multi"))
		}
	}
	if r.sortingOrder != nil {
		t := *r.sortingOrder
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("sorting_order", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("sorting_order", parameterToString(t, "multi"))
		}
	}
	if r.includeArchived != nil {
		localVarQueryParams.Add("include_archived", parameterToString(*r.includeArchived, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v CursorPaginatedResponseTagModel
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchAggregatedTagsRequest struct {
	ctx                        context.Context
	ApiService                 *TagsApiService
	companyId                  *string
	before                     *string
	after                      *string
	offset                     *int64
	limit                      *int32
	sortingKeys                *[]string
	sortingOrder               *[]PageOrder
	aggregatedTagSearchRequest *AggregatedTagSearchRequest
}

func (r ApiSearchAggregatedTagsRequest) CompanyId(companyId string) ApiSearchAggregatedTagsRequest {
	r.companyId = &companyId
	return r
}

// Lower bound of the page of data to return (cannot be used together with [after] or [offset])
func (r ApiSearchAggregatedTagsRequest) Before(before string) ApiSearchAggregatedTagsRequest {
	r.before = &before
	return r
}

// Upper bound of the page of data to return (cannot be used together with [before] or [offset])
func (r ApiSearchAggregatedTagsRequest) After(after string) ApiSearchAggregatedTagsRequest {
	r.after = &after
	return r
}

// Offset of the page of data to return (cannot be used together with [before] or [after])
func (r ApiSearchAggregatedTagsRequest) Offset(offset int64) ApiSearchAggregatedTagsRequest {
	r.offset = &offset
	return r
}

// The maximum amount of items to return
func (r ApiSearchAggregatedTagsRequest) Limit(limit int32) ApiSearchAggregatedTagsRequest {
	r.limit = &limit
	return r
}

// The keys to sort the results by
func (r ApiSearchAggregatedTagsRequest) SortingKeys(sortingKeys []string) ApiSearchAggregatedTagsRequest {
	r.sortingKeys = &sortingKeys
	return r
}

// The order to sort the results by. Must be the same length as [sortingKeys]; one order per key
func (r ApiSearchAggregatedTagsRequest) SortingOrder(sortingOrder []PageOrder) ApiSearchAggregatedTagsRequest {
	r.sortingOrder = &sortingOrder
	return r
}

func (r ApiSearchAggregatedTagsRequest) AggregatedTagSearchRequest(aggregatedTagSearchRequest AggregatedTagSearchRequest) ApiSearchAggregatedTagsRequest {
	r.aggregatedTagSearchRequest = &aggregatedTagSearchRequest
	return r
}

func (r ApiSearchAggregatedTagsRequest) Execute() (*CursorPaginatedResponseAggregatedTagModel, *http.Response, error) {
	return r.ApiService.SearchAggregatedTagsExecute(r)
}

/*
SearchAggregatedTags Search and return aggregated tags

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSearchAggregatedTagsRequest
*/
func (a *TagsApiService) SearchAggregatedTags(ctx context.Context) ApiSearchAggregatedTagsRequest {
	return ApiSearchAggregatedTagsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return CursorPaginatedResponseAggregatedTagModel
func (a *TagsApiService) SearchAggregatedTagsExecute(r ApiSearchAggregatedTagsRequest) (*CursorPaginatedResponseAggregatedTagModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CursorPaginatedResponseAggregatedTagModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagsApiService.SearchAggregatedTags")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v0/aggregations/tags"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.companyId != nil {
		localVarQueryParams.Add("company_id", parameterToString(*r.companyId, ""))
	}
	if r.before != nil {
		localVarQueryParams.Add("before", parameterToString(*r.before, ""))
	}
	if r.after != nil {
		localVarQueryParams.Add("after", parameterToString(*r.after, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.sortingKeys != nil {
		t := *r.sortingKeys
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("sorting_keys", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("sorting_keys", parameterToString(t, "multi"))
		}
	}
	if r.sortingOrder != nil {
		t := *r.sortingOrder
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("sorting_order", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("sorting_order", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aggregatedTagSearchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v CursorPaginatedResponseAggregatedTagModel
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchTagsRequest struct {
	ctx          context.Context
	ApiService   *TagsApiService
	companyId    *string
	textSearch   *string
	before       *string
	after        *string
	offset       *int64
	limit        *int32
	sortingKeys  *[]string
	sortingOrder *[]PageOrder
}

func (r ApiSearchTagsRequest) CompanyId(companyId string) ApiSearchTagsRequest {
	r.companyId = &companyId
	return r
}

func (r ApiSearchTagsRequest) TextSearch(textSearch string) ApiSearchTagsRequest {
	r.textSearch = &textSearch
	return r
}

// Lower bound of the page of data to return (cannot be used together with [after] or [offset])
func (r ApiSearchTagsRequest) Before(before string) ApiSearchTagsRequest {
	r.before = &before
	return r
}

// Upper bound of the page of data to return (cannot be used together with [before] or [offset])
func (r ApiSearchTagsRequest) After(after string) ApiSearchTagsRequest {
	r.after = &after
	return r
}

// Offset of the page of data to return (cannot be used together with [before] or [after])
func (r ApiSearchTagsRequest) Offset(offset int64) ApiSearchTagsRequest {
	r.offset = &offset
	return r
}

// The maximum amount of items to return
func (r ApiSearchTagsRequest) Limit(limit int32) ApiSearchTagsRequest {
	r.limit = &limit
	return r
}

// The keys to sort the results by
func (r ApiSearchTagsRequest) SortingKeys(sortingKeys []string) ApiSearchTagsRequest {
	r.sortingKeys = &sortingKeys
	return r
}

// The order to sort the results by. Must be the same length as [sortingKeys]; one order per key
func (r ApiSearchTagsRequest) SortingOrder(sortingOrder []PageOrder) ApiSearchTagsRequest {
	r.sortingOrder = &sortingOrder
	return r
}

func (r ApiSearchTagsRequest) Execute() (*CursorPaginatedResponseTagModel, *http.Response, error) {
	return r.ApiService.SearchTagsExecute(r)
}

/*
SearchTags Search tags

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSearchTagsRequest
*/
func (a *TagsApiService) SearchTags(ctx context.Context) ApiSearchTagsRequest {
	return ApiSearchTagsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return CursorPaginatedResponseTagModel
func (a *TagsApiService) SearchTagsExecute(r ApiSearchTagsRequest) (*CursorPaginatedResponseTagModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CursorPaginatedResponseTagModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagsApiService.SearchTags")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v0/tags"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.companyId != nil {
		localVarQueryParams.Add("company_id", parameterToString(*r.companyId, ""))
	}
	if r.textSearch != nil {
		localVarQueryParams.Add("text_search", parameterToString(*r.textSearch, ""))
	}
	if r.before != nil {
		localVarQueryParams.Add("before", parameterToString(*r.before, ""))
	}
	if r.after != nil {
		localVarQueryParams.Add("after", parameterToString(*r.after, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.sortingKeys != nil {
		t := *r.sortingKeys
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("sorting_keys", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("sorting_keys", parameterToString(t, "multi"))
		}
	}
	if r.sortingOrder != nil {
		t := *r.sortingOrder
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("sorting_order", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("sorting_order", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v CursorPaginatedResponseTagModel
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateDimensionValueRequest struct {
	ctx                          context.Context
	ApiService                   *TagsApiService
	tagId                        string
	dimensionId                  string
	tagDimensionValueUpdateModel *TagDimensionValueUpdateModel
}

func (r ApiUpdateDimensionValueRequest) TagDimensionValueUpdateModel(tagDimensionValueUpdateModel TagDimensionValueUpdateModel) ApiUpdateDimensionValueRequest {
	r.tagDimensionValueUpdateModel = &tagDimensionValueUpdateModel
	return r
}

func (r ApiUpdateDimensionValueRequest) Execute() (*DataResponseTagDimensionValueModel, *http.Response, error) {
	return r.ApiService.UpdateDimensionValueExecute(r)
}

/*
UpdateDimensionValue Updates a dimension value

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tagId
	@param dimensionId
	@return ApiUpdateDimensionValueRequest
*/
func (a *TagsApiService) UpdateDimensionValue(ctx context.Context, tagId string, dimensionId string) ApiUpdateDimensionValueRequest {
	return ApiUpdateDimensionValueRequest{
		ApiService:  a,
		ctx:         ctx,
		tagId:       tagId,
		dimensionId: dimensionId,
	}
}

// Execute executes the request
//
//	@return DataResponseTagDimensionValueModel
func (a *TagsApiService) UpdateDimensionValueExecute(r ApiUpdateDimensionValueRequest) (*DataResponseTagDimensionValueModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DataResponseTagDimensionValueModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagsApiService.UpdateDimensionValue")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v0/tags/{tagId}/dimensions/{dimensionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"tagId"+"}", url.PathEscape(parameterToString(r.tagId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"dimensionId"+"}", url.PathEscape(parameterToString(r.dimensionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tagDimensionValueUpdateModel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v DataResponseTagDimensionValueModel
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateTagRequest struct {
	ctx            context.Context
	ApiService     *TagsApiService
	tagId          string
	tagUpdateModel *TagUpdateModel
}

func (r ApiUpdateTagRequest) TagUpdateModel(tagUpdateModel TagUpdateModel) ApiUpdateTagRequest {
	r.tagUpdateModel = &tagUpdateModel
	return r
}

func (r ApiUpdateTagRequest) Execute() (*DataResponseTagModel, *http.Response, error) {
	return r.ApiService.UpdateTagExecute(r)
}

/*
UpdateTag Updates tag by id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tagId
	@return ApiUpdateTagRequest
*/
func (a *TagsApiService) UpdateTag(ctx context.Context, tagId string) ApiUpdateTagRequest {
	return ApiUpdateTagRequest{
		ApiService: a,
		ctx:        ctx,
		tagId:      tagId,
	}
}

// Execute executes the request
//
//	@return DataResponseTagModel
func (a *TagsApiService) UpdateTagExecute(r ApiUpdateTagRequest) (*DataResponseTagModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DataResponseTagModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagsApiService.UpdateTag")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v0/tags/{tagId}"
	localVarPath = strings.Replace(localVarPath, "{"+"tagId"+"}", url.PathEscape(parameterToString(r.tagId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tagUpdateModel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v DataResponseTagModel
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
