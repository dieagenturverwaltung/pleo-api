/*
Tags API

Tags OpenAPI definitions

API version: 31.38.0
Contact: team-expense-core@pleo.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package tags

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"reflect"
	"strings"
)

// TagGroupsApiService TagGroupsApi service
type TagGroupsApiService service

type ApiCreateTagGroupRequest struct {
	ctx                 context.Context
	ApiService          *TagGroupsApiService
	companyId           *string
	tagGroupCreateModel *TagGroupCreateModel
}

func (r ApiCreateTagGroupRequest) CompanyId(companyId string) ApiCreateTagGroupRequest {
	r.companyId = &companyId
	return r
}

func (r ApiCreateTagGroupRequest) TagGroupCreateModel(tagGroupCreateModel TagGroupCreateModel) ApiCreateTagGroupRequest {
	r.tagGroupCreateModel = &tagGroupCreateModel
	return r
}

func (r ApiCreateTagGroupRequest) Execute() (*DataResponseTagGroupModel, *http.Response, error) {
	return r.ApiService.CreateTagGroupExecute(r)
}

/*
CreateTagGroup Creates a new tag group resource

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateTagGroupRequest
*/
func (a *TagGroupsApiService) CreateTagGroup(ctx context.Context) ApiCreateTagGroupRequest {
	return ApiCreateTagGroupRequest{
		ApiService: a,
		ctx:        ctx,
		companyId:  a.client.cfg.CompanyID,
	}
}

// Execute executes the request
//
//	@return DataResponseTagGroupModel
func (a *TagGroupsApiService) CreateTagGroupExecute(r ApiCreateTagGroupRequest) (*DataResponseTagGroupModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DataResponseTagGroupModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagGroupsApiService.CreateTagGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v0/tag-groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.companyId != nil {
		localVarQueryParams.Add("company_id", parameterToString(*r.companyId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tagGroupCreateModel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v DataResponseTagGroupModel
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateTagGroupDimensionRequest struct {
	ctx                          context.Context
	ApiService                   *TagGroupsApiService
	groupId                      string
	tagGroupDimensionCreateModel *TagGroupDimensionCreateModel
}

func (r ApiCreateTagGroupDimensionRequest) TagGroupDimensionCreateModel(tagGroupDimensionCreateModel TagGroupDimensionCreateModel) ApiCreateTagGroupDimensionRequest {
	r.tagGroupDimensionCreateModel = &tagGroupDimensionCreateModel
	return r
}

func (r ApiCreateTagGroupDimensionRequest) Execute() (*DataResponseTagGroupDimensionModel, *http.Response, error) {
	return r.ApiService.CreateTagGroupDimensionExecute(r)
}

/*
CreateTagGroupDimension Creates a new tag group dimension

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupId
	@return ApiCreateTagGroupDimensionRequest
*/
func (a *TagGroupsApiService) CreateTagGroupDimension(ctx context.Context, groupId string) ApiCreateTagGroupDimensionRequest {
	return ApiCreateTagGroupDimensionRequest{
		ApiService: a,
		ctx:        ctx,
		groupId:    groupId,
	}
}

// Execute executes the request
//
//	@return DataResponseTagGroupDimensionModel
func (a *TagGroupsApiService) CreateTagGroupDimensionExecute(r ApiCreateTagGroupDimensionRequest) (*DataResponseTagGroupDimensionModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DataResponseTagGroupDimensionModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagGroupsApiService.CreateTagGroupDimension")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v0/tag-groups/{groupId}/dimensions"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tagGroupDimensionCreateModel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v DataResponseTagGroupDimensionModel
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteTagGroupRequest struct {
	ctx        context.Context
	ApiService *TagGroupsApiService
	groupId    string
}

func (r ApiDeleteTagGroupRequest) Execute() (bool, *http.Response, error) {
	return r.ApiService.DeleteTagGroupExecute(r)
}

/*
DeleteTagGroup Deletes the tag group resource by id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupId
	@return ApiDeleteTagGroupRequest
*/
func (a *TagGroupsApiService) DeleteTagGroup(ctx context.Context, groupId string) ApiDeleteTagGroupRequest {
	return ApiDeleteTagGroupRequest{
		ApiService: a,
		ctx:        ctx,
		groupId:    groupId,
	}
}

// Execute executes the request
//
//	@return bool
func (a *TagGroupsApiService) DeleteTagGroupExecute(r ApiDeleteTagGroupRequest) (bool, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue bool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagGroupsApiService.DeleteTagGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v0/tag-groups/{groupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v bool
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteTagGroupDimensionRequest struct {
	ctx         context.Context
	ApiService  *TagGroupsApiService
	groupId     string
	dimensionId string
}

func (r ApiDeleteTagGroupDimensionRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteTagGroupDimensionExecute(r)
}

/*
DeleteTagGroupDimension Delete a tag group dimension

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupId
	@param dimensionId
	@return ApiDeleteTagGroupDimensionRequest
*/
func (a *TagGroupsApiService) DeleteTagGroupDimension(ctx context.Context, groupId string, dimensionId string) ApiDeleteTagGroupDimensionRequest {
	return ApiDeleteTagGroupDimensionRequest{
		ApiService:  a,
		ctx:         ctx,
		groupId:     groupId,
		dimensionId: dimensionId,
	}
}

// Execute executes the request
func (a *TagGroupsApiService) DeleteTagGroupDimensionExecute(r ApiDeleteTagGroupDimensionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagGroupsApiService.DeleteTagGroupDimension")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v0/tag-groups/{groupId}/dimensions/{dimensionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"dimensionId"+"}", url.PathEscape(parameterToString(r.dimensionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAggregatedTagGroupsRequest struct {
	ctx            context.Context
	ApiService     *TagGroupsApiService
	companyId      *string
	organizationId *string
	tagGroupIds    *[]string
}

func (r ApiGetAggregatedTagGroupsRequest) CompanyId(companyId string) ApiGetAggregatedTagGroupsRequest {
	r.companyId = &companyId
	return r
}

func (r ApiGetAggregatedTagGroupsRequest) OrganizationId(organizationId string) ApiGetAggregatedTagGroupsRequest {
	r.organizationId = &organizationId
	return r
}

func (r ApiGetAggregatedTagGroupsRequest) TagGroupIds(tagGroupIds []string) ApiGetAggregatedTagGroupsRequest {
	r.tagGroupIds = &tagGroupIds
	return r
}

func (r ApiGetAggregatedTagGroupsRequest) Execute() (*DataResponseListAggregatedTagGroupModel, *http.Response, error) {
	return r.ApiService.GetAggregatedTagGroupsExecute(r)
}

/*
GetAggregatedTagGroups Returns all tag groups for given company in an aggregated format

You need to supply either the company_id or the organization_id query parameter. If you supply both, the company_id will be used. If you supply neither, the request will fail. If you supply the company_id, the response will contain only the tag groups for that company. If you supply the organization_id, the response will contain the tag groups for all companies in the organization. If you supply the company_id and the organization_id, the response will contain only the tag groups for the company.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetAggregatedTagGroupsRequest
*/
func (a *TagGroupsApiService) GetAggregatedTagGroups(ctx context.Context) ApiGetAggregatedTagGroupsRequest {
	return ApiGetAggregatedTagGroupsRequest{
		ApiService: a,
		ctx:        ctx,
		companyId:  a.client.cfg.CompanyID,
	}
}

// Execute executes the request
//
//	@return DataResponseListAggregatedTagGroupModel
func (a *TagGroupsApiService) GetAggregatedTagGroupsExecute(r ApiGetAggregatedTagGroupsRequest) (*DataResponseListAggregatedTagGroupModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DataResponseListAggregatedTagGroupModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagGroupsApiService.GetAggregatedTagGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v0/aggregations/tag-groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.companyId != nil {
		localVarQueryParams.Add("company_id", parameterToString(*r.companyId, ""))
	}
	if r.organizationId != nil {
		localVarQueryParams.Add("organization_id", parameterToString(*r.organizationId, ""))
	}
	if r.tagGroupIds != nil {
		t := *r.tagGroupIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tag_group_ids", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tag_group_ids", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v DataResponseListAggregatedTagGroupModel
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTagGroupRequest struct {
	ctx        context.Context
	ApiService *TagGroupsApiService
	groupId    string
}

func (r ApiGetTagGroupRequest) Execute() (*DataResponseTagGroupModel, *http.Response, error) {
	return r.ApiService.GetTagGroupExecute(r)
}

/*
GetTagGroup Returns the tag group resource by id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupId
	@return ApiGetTagGroupRequest
*/
func (a *TagGroupsApiService) GetTagGroup(ctx context.Context, groupId string) ApiGetTagGroupRequest {
	return ApiGetTagGroupRequest{
		ApiService: a,
		ctx:        ctx,
		groupId:    groupId,
	}
}

// Execute executes the request
//
//	@return DataResponseTagGroupModel
func (a *TagGroupsApiService) GetTagGroupExecute(r ApiGetTagGroupRequest) (*DataResponseTagGroupModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DataResponseTagGroupModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagGroupsApiService.GetTagGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v0/tag-groups/{groupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v DataResponseTagGroupModel
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTagGroupDimensionRequest struct {
	ctx         context.Context
	ApiService  *TagGroupsApiService
	groupId     string
	dimensionId string
}

func (r ApiGetTagGroupDimensionRequest) Execute() (*DataResponseTagGroupDimensionModel, *http.Response, error) {
	return r.ApiService.GetTagGroupDimensionExecute(r)
}

/*
GetTagGroupDimension Get a tag group dimension

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupId
	@param dimensionId
	@return ApiGetTagGroupDimensionRequest
*/
func (a *TagGroupsApiService) GetTagGroupDimension(ctx context.Context, groupId string, dimensionId string) ApiGetTagGroupDimensionRequest {
	return ApiGetTagGroupDimensionRequest{
		ApiService:  a,
		ctx:         ctx,
		groupId:     groupId,
		dimensionId: dimensionId,
	}
}

// Execute executes the request
//
//	@return DataResponseTagGroupDimensionModel
func (a *TagGroupsApiService) GetTagGroupDimensionExecute(r ApiGetTagGroupDimensionRequest) (*DataResponseTagGroupDimensionModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DataResponseTagGroupDimensionModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagGroupsApiService.GetTagGroupDimension")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v0/tag-groups/{groupId}/dimensions/{dimensionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"dimensionId"+"}", url.PathEscape(parameterToString(r.dimensionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v DataResponseTagGroupDimensionModel
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTagGroupDimensionsRequest struct {
	ctx        context.Context
	ApiService *TagGroupsApiService
	groupId    string
}

func (r ApiGetTagGroupDimensionsRequest) Execute() (*DataResponseListTagGroupDimensionModel, *http.Response, error) {
	return r.ApiService.GetTagGroupDimensionsExecute(r)
}

/*
GetTagGroupDimensions Get a list of tag group dimensions

This endpoint will return a list of tag group dimensions excluding the name and code dimensions which are always present in a tag group. The name and code dimensions are returned only when they do not follow the standard name and code naming convention.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupId
	@return ApiGetTagGroupDimensionsRequest
*/
func (a *TagGroupsApiService) GetTagGroupDimensions(ctx context.Context, groupId string) ApiGetTagGroupDimensionsRequest {
	return ApiGetTagGroupDimensionsRequest{
		ApiService: a,
		ctx:        ctx,
		groupId:    groupId,
	}
}

// Execute executes the request
//
//	@return DataResponseListTagGroupDimensionModel
func (a *TagGroupsApiService) GetTagGroupDimensionsExecute(r ApiGetTagGroupDimensionsRequest) (*DataResponseListTagGroupDimensionModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DataResponseListTagGroupDimensionModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagGroupsApiService.GetTagGroupDimensions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v0/tag-groups/{groupId}/dimensions"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v DataResponseListTagGroupDimensionModel
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTagGroupsRequest struct {
	ctx            context.Context
	ApiService     *TagGroupsApiService
	companyId      *string
	organizationId *string
}

func (r ApiGetTagGroupsRequest) CompanyId(companyId string) ApiGetTagGroupsRequest {
	r.companyId = &companyId
	return r
}

func (r ApiGetTagGroupsRequest) OrganizationId(organizationId string) ApiGetTagGroupsRequest {
	r.organizationId = &organizationId
	return r
}

func (r ApiGetTagGroupsRequest) Execute() (*DataResponseListTagGroupModel, *http.Response, error) {
	return r.ApiService.GetTagGroupsExecute(r)
}

/*
GetTagGroups Returns all tag groups for given company

You need to supply either the company_id or the organization_id query parameter. If you supply both, the company_id will be used. If you supply neither, the request will fail. If you supply the company_id, the response will contain only the tag groups for that company. If you supply the organization_id, the response will contain the tag groups for all companies in the organization. If you supply the company_id and the organization_id, the response will contain only the tag groups for the company.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetTagGroupsRequest
*/
func (a *TagGroupsApiService) GetTagGroups(ctx context.Context) ApiGetTagGroupsRequest {
	return ApiGetTagGroupsRequest{
		ApiService: a,
		ctx:        ctx,
		companyId:  a.client.cfg.CompanyID,
	}
}

// Execute executes the request
//
//	@return DataResponseListTagGroupModel
func (a *TagGroupsApiService) GetTagGroupsExecute(r ApiGetTagGroupsRequest) (*DataResponseListTagGroupModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DataResponseListTagGroupModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagGroupsApiService.GetTagGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v0/tag-groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.companyId != nil {
		localVarQueryParams.Add("company_id", parameterToString(*r.companyId, ""))
	}
	if r.organizationId != nil {
		localVarQueryParams.Add("organization_id", parameterToString(*r.organizationId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v DataResponseListTagGroupModel
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateTagGroupRequest struct {
	ctx                 context.Context
	ApiService          *TagGroupsApiService
	groupId             string
	tagGroupUpdateModel *TagGroupUpdateModel
}

func (r ApiUpdateTagGroupRequest) TagGroupUpdateModel(tagGroupUpdateModel TagGroupUpdateModel) ApiUpdateTagGroupRequest {
	r.tagGroupUpdateModel = &tagGroupUpdateModel
	return r
}

func (r ApiUpdateTagGroupRequest) Execute() (*DataResponseTagGroupModel, *http.Response, error) {
	return r.ApiService.UpdateTagGroupExecute(r)
}

/*
UpdateTagGroup Updates the tag group resource by id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupId
	@return ApiUpdateTagGroupRequest
*/
func (a *TagGroupsApiService) UpdateTagGroup(ctx context.Context, groupId string) ApiUpdateTagGroupRequest {
	return ApiUpdateTagGroupRequest{
		ApiService: a,
		ctx:        ctx,
		groupId:    groupId,
	}
}

// Execute executes the request
//
//	@return DataResponseTagGroupModel
func (a *TagGroupsApiService) UpdateTagGroupExecute(r ApiUpdateTagGroupRequest) (*DataResponseTagGroupModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DataResponseTagGroupModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagGroupsApiService.UpdateTagGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v0/tag-groups/{groupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tagGroupUpdateModel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v DataResponseTagGroupModel
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateTagGroupDimensionRequest struct {
	ctx                          context.Context
	ApiService                   *TagGroupsApiService
	groupId                      string
	dimensionId                  string
	tagGroupDimensionUpdateModel *TagGroupDimensionUpdateModel
}

func (r ApiUpdateTagGroupDimensionRequest) TagGroupDimensionUpdateModel(tagGroupDimensionUpdateModel TagGroupDimensionUpdateModel) ApiUpdateTagGroupDimensionRequest {
	r.tagGroupDimensionUpdateModel = &tagGroupDimensionUpdateModel
	return r
}

func (r ApiUpdateTagGroupDimensionRequest) Execute() (*DataResponseTagGroupDimensionModel, *http.Response, error) {
	return r.ApiService.UpdateTagGroupDimensionExecute(r)
}

/*
UpdateTagGroupDimension Update a tag group dimension

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupId
	@param dimensionId
	@return ApiUpdateTagGroupDimensionRequest
*/
func (a *TagGroupsApiService) UpdateTagGroupDimension(ctx context.Context, groupId string, dimensionId string) ApiUpdateTagGroupDimensionRequest {
	return ApiUpdateTagGroupDimensionRequest{
		ApiService:  a,
		ctx:         ctx,
		groupId:     groupId,
		dimensionId: dimensionId,
	}
}

// Execute executes the request
//
//	@return DataResponseTagGroupDimensionModel
func (a *TagGroupsApiService) UpdateTagGroupDimensionExecute(r ApiUpdateTagGroupDimensionRequest) (*DataResponseTagGroupDimensionModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DataResponseTagGroupDimensionModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagGroupsApiService.UpdateTagGroupDimension")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v0/tag-groups/{groupId}/dimensions/{dimensionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"dimensionId"+"}", url.PathEscape(parameterToString(r.dimensionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tagGroupDimensionUpdateModel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v DataResponseTagGroupDimensionModel
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
